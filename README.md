## 📚 프로젝트 배경

사용자가 영화를 선택할 때, **장르별로 높은 평점을 받은 영화를 빠르게 추천**해주는 시스템을 구현하고자 했습니다.  
기존에는 사용자가 원하는 장르의 영화를 일일이 찾아보며 평점을 비교해야 했지만,  
본 프로젝트에서는 **각 영화에 대한 여러 유저의 평점을 평균화**하여,  
**장르별로 평점이 가장 높은 영화**를 손쉽게 확인할 수 있도록 돕는 것이 출발점이었습니다.

> 🎬 예시: "코미디 장르 중에서 평균 평점이 가장 높은 영화 TOP 5를 보여줘!"

---

## 🎯 프로젝트 목표

파티셔닝 적용 전후의 **조회 성능 차이를 비교 분석**하고,  
**파티셔닝이 실제로 성능 개선에 얼마나 효과적인지 실험적으로 확인**하는 것을 최종 목표로 합니다.

---

## 📋 진행 계획

| 단계 | 내용 | 상태 |
|------|------|------|
| 1단계 | CSV → MySQL 데이터 이관 | ✅ 완료 |
| 2단계 | 테이블 설계 및 생성 | 🔄 진행 중 |
| 2단계 | 성능 비교를 위한 실험환경 통제 | 🔄 진행 중 |
| 3단계 | 파티셔닝 전 조건별 조회 쿼리 및 시간 측정 | 🔲 예정 |
| 4단계 | 파티셔닝 후 조건별 조회 쿼리 및 시간 측정 | 🔲 예정 |
| 5단계 | 성능 비교 결과 정리 및 결론 도출 | 🔲 예정 |

---

## 🚀 파티셔닝 기대 효과

| 개선 포인트 | 설명 |
|-------------|------|
| 🔍 **파티션 프루닝** | 원하는 기간의 평점만 빠르게 검색 가능 → 전체 스캔 방지 |
| ⚡ **조회 속도 향상** | 장르별 상위 평점 영화 조회 시, 최신 평점만 빠르게 필터링 가능 |
| 🧠 **실시간 추천 성능 개선** | 실시간에 가까운 추천 서비스 구현에 적합한 구조 |
| 📈 **확장성 확보** | 데이터 양이 증가해도 기간별로 분산 저장되므로 성능 저하 최소화 |

---

## 💡 기대 결과

- 사용자는 "장르별로 평균 평점이 가장 높은 영화"를 손쉽고 빠르게 확인할 수 있음
- 대용량 영화 평점 데이터를 효과적으로 처리하며, **실제 영화 추천 시스템과 유사한 구조**를 학습


---

### 🔸 트러블슈팅 포인트

- ✅ **Partition Key 선정이 매우 중요**: 자주 조회되는 조건에 맞춰야 효과가 큼 (id를 할건지, review를 할건지) 
- ❗ **Hash 기반 파티셔닝은 파티션 수 변경이 어려움** → 초기 설계가 중요  
- ✅ DBeaver에서는 `EXPLAIN`을 통해 어떤 파티션이 조회되었는지 확인 가능  
- ❗ `WHERE`절에 **파티션 키가 포함되지 않으면** → 파티션 프루닝이 적용되지 않음 → 성능 향상 없음

---

## ⚙️ 기술 스택

| 구분 | 사용 도구 |
|------|-----------|
| DBMS | MySQL 8.x |
| DB 툴 | DBeaver |
| 백엔드 | Java 21 |
| JDBC 드라이버 | mysql-connector-java |
| 빌드 도구 | Gradle |
| OS | Windows 11 or macOS |

---

### 📌 결론 및 회고

> 파티셔닝은 단순히 데이터를 나누는 것이 아니라,  
> **조회 패턴을 고려한 물리적 구조 최적화 전략**입니다.  
> 정규화와는 목적과 시점이 다르며,  
> **대용량 데이터 처리에 필수적인 튜닝 기법**으로써 성능 향상에 직접적인 영향을 줍니다.
